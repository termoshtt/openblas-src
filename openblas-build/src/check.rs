//! Check make results

use anyhow::Result;
use std::{
    collections::HashSet,
    fs,
    hash::Hash,
    io::{self, BufRead},
    path::*,
};

#[derive(Debug, Clone, Default)]
pub struct LinkInfo {
    pub search_paths: Vec<PathBuf>,
    pub libs: Vec<String>,
}

fn as_sorted_vec<T: Hash + Ord>(set: HashSet<T>) -> Vec<T> {
    let mut v: Vec<_> = set.into_iter().collect();
    v.sort();
    v
}

impl LinkInfo {
    fn parse(line: &str) -> Self {
        let mut search_paths = HashSet::new();
        let mut libs = HashSet::new();
        for entry in line.split(" ") {
            if entry.starts_with("-L") {
                let path = PathBuf::from(entry.trim_start_matches("-L"));
                if !path.exists() {
                    continue;
                }
                search_paths.insert(path.canonicalize().expect("Failed to canonicalize path"));
            }
            if entry.starts_with("-l") {
                libs.insert(entry.trim_start_matches("-l").into());
            }
        }
        LinkInfo {
            search_paths: as_sorted_vec(search_paths),
            libs: as_sorted_vec(libs),
        }
    }
}

/// Parse Makefile.conf which generated by OpenBLAS make system
#[derive(Debug, Clone, Default)]
pub struct MakeConf {
    os_name: String,
    no_fortran: bool,
    c_extra_libs: LinkInfo,
    f_extra_libs: LinkInfo,
}

impl MakeConf {
    /// Parse from file
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let mut detail = MakeConf::default();
        let f = fs::File::open(path)?;
        let buf = io::BufReader::new(f);
        for line in buf.lines() {
            let line = line.unwrap();
            if line.len() == 0 {
                continue;
            }
            let entry: Vec<_> = line.split("=").collect();
            if entry.len() != 2 {
                continue;
            }
            match entry[0] {
                "OSNAME" => detail.os_name = entry[1].into(),
                "NOFORTRAN" => detail.no_fortran = true,
                "CEXTRALIB" => detail.c_extra_libs = LinkInfo::parse(entry[1]),
                "FEXTRALIB" => detail.f_extra_libs = LinkInfo::parse(entry[1]),
                _ => continue,
            }
        }
        Ok(detail)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn detail_from_makefile_conf() {
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("Makefile.conf");
        assert!(path.exists());
        let detail = MakeConf::new(path).unwrap();
        assert!(!detail.no_fortran);
    }

    #[test]
    fn detail_from_nofortran_conf() {
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("nofortran.conf");
        assert!(path.exists());
        let detail = MakeConf::new(path).unwrap();
        assert!(detail.no_fortran);
    }

    #[test]
    fn link_info_parse() {
        // from nofortran.conf
        let info = LinkInfo::parse("-L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../..  -lc");
        assert_eq!(info.libs, vec!["c"]);
    }
}
